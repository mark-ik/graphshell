<!-- This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. -->

# Persistence Hub Plan (2026-02-19)

**Status**: Archived (2026-02-22).
**Superseded by**:
- `2026-02-20_settings_architecture_plan.md` (UI, Session Backend, Maintenance)
- `2026-02-20_node_badge_and_tagging_plan.md` (Tags/Bookmarks)
- `2026-02-20_edge_traversal_impl_plan.md` (History)

---

**Settings architecture cross-reference (2026-02-20):**
The UI delivery destination for each phase has been superseded by the settings architecture plan
(`2026-02-20_settings_architecture_plan.md`). Settings pages, not floating panels, are the primary
delivery surfaces going forward:

| Phase | Delivery surface |
| --- | --- |
| Phase 1 (Tags) | `graphshell://settings/bookmarks` |
| Phase 2 (Node History) | `graphshell://settings/history` |
| Phase 3 (Maintenance) | `graphshell://settings/persistence` |
| Phase 4 (Encryption) | Already implemented; config in `graphshell://settings/persistence` |
| Phase 5 (Session Architecture) | `graphshell://settings/persistence` (diagnostics) |

---

### Implemented Baseline (2026-02-20)

The following cross-cutting runtime/sessioning pieces are now implemented and visible through the
Persistence Hub:

- Active webview budget policy (DEFAULT_ACTIVE_WEBVIEW_LIMIT = 4) with LRU overflow demotion
  from `Active` to `Warm`.
- Warm cache budget policy (DEFAULT_WARM_CACHE_LIMIT = 12) with LRU overflow eviction from
  `Warm` to `Cold`.
- Memory-pressure-aware lifecycle adjustment (normal/warning/critical), including stronger active
  evictions under pressure.
- Persistence Hub diagnostics rows for:
  - lifecycle counts (`Active`, `Warm`, `Cold`),
  - configured active/warm limits,
  - mapped webview count,
  - memory pressure status and available/total memory.

These are baseline controls/telemetry only; user-configurable lifecycle budgets and advanced
retention heuristics are still future work.

### Newly Implemented Slices (2026-02-20)

- **LRU terminology + behavior**: runtime active/warm lifecycle caches now use explicit LRU
  ordering (`oldest -> newest`) and evict oldest non-protected entries.
- **Session restore fidelity payload**:
  - Added persisted `NodeSessionState` payload on each node snapshot
    (history entries/index, scroll x/y, optional form draft).
  - Snapshot restore now prefers `NodeSessionState` when present and backfills from legacy
    history fields when absent.
  - Cold reactivation URL selection now prefers the URL at restored history index.
  - Form draft metadata writes are feature-guarded (`GRAPHSHELL_ENABLE_FORM_DRAFT`).
- **Encryption at rest**:
  - Added persistence write pipeline: `rkyv -> zstd -> AES-256-GCM`.
  - Added read compatibility for both encrypted payloads and legacy plaintext payloads.
  - Added key management via OS keyring (`keyring` crate; per-store account key).
  - Added startup legacy detection + in-place migration to encrypted payloads.
  - Applied encrypted storage to fjall log entries and redb snapshot/layout payloads.

---
## Plan

### Context

The Persistence Hub panel (`Persist` toolbar entry) currently handles:

- Named workspace snapshot save/list/restore/delete.
- Named graph snapshot save/list/load/delete.
- Session autosave: startup restore of `workspace:session-latest`, autosave on layout change,
  configurable cadence and `session-prev-N` retention.
- Session workspace prune.

This plan adds three new scopes, outlined in
`2026-02-18_edge_operations_and_cmd_palette_plan.md §Remaining #3`:
Bookmarks, Node History, and Maintenance.

### User Feedback Intake (2026-02-19)

Additional persistence UX requests from manual validation:

1. Replace separate "Pin Workspace Snapshot" and pane pinning affordances with a single
   context-aware pin action (targets focused workspace or focused pane).
2. Add a unified pin-load menu listing recent pins (suggested size: 5-10), with autogenerated
   labels identifying pin type (`pane` vs `workbench/workspace`) plus workspace tab membership
   summary.
3. Add one-click maintenance actions for:
   - delete all pins,
   - delete all autosaves except the most recent.
4. Prefer explicit save/load controls over background warning prompts:
   - one-click auto-named workspace save,
   - load from a clear picker/list flow,
   - avoid repeated modal warnings during normal graph navigation.

These are not implemented yet; schedule under Phase 3 (Maintenance) and panel UX refactor.

The older `2026-02-11_bookmarks_history_import_plan.md` (FT7) is superseded for the features
covered here — it predates UUID-keyed node identity, the workspace model, and the current
Persistence Hub architecture. The import-from-browser wizard (Firefox/Chrome file import) remains
as FT7 and is out of scope.

---

### Phase 1: Tags

A unified tagging system replacing the previous `is_bookmarked: bool` and `is_pinned: bool` scalar
fields. Tags are user-applied node attributes, not graph relationships. Special built-in tags carry
behavioral effects; user-defined tags are purely organizational.

See `2026-02-20_node_badge_and_tagging_plan.md` for the badge visual system and tag assignment UI.

#### Special Tags

The `#` prefix is the reserved system namespace. Full table and namespace convention in
`2026-02-20_node_badge_and_tagging_plan.md` (Tag Namespace Convention section).

| Tag | Behavior |
| --- | --- |
| `#pin` | Physics anchor — node not displaced by the simulation. |
| `#starred` | Soft bookmark. Surfaces via `@b` scope and `is:starred` predicate. |
| `#archive` | Hidden from default graph view; node rendered at reduced opacity. Not deleted. |
| `#resident` | Never cold-evicted regardless of workspace. Global complement to `tile.is_resident`. |
| `#private` | URL and title redacted in overlays when screen-sharing mode active; excluded from JSON export. |
| `#nohistory` | Navigating through this node does not push a traversal entry. |
| `#monitor` | Periodically reload and compare DOM hash; badge/toast on content change. |
| `#unread` | Auto-applied on node add or URL change; cleared on first activation. |
| `#focus` | Boosts DOI score; floats node toward center in the layout. Short-term attention marker. |
| `#clip` | Node is a clipped DOM element (web clip). Distinct node shape/border in graph view. Export includes HTML snippet and screenshot. Cross-ref: clipping DOM extraction plan. |

User-defined tags without `#` (`work`, `research`, `todo`) carry no system behavior and are
rendered as label chips on the node and in the tab header.

#### Data Model

- Replace `is_bookmarked: bool` and `is_pinned: bool` on `Node` with `tags: HashSet<String>`.
- Persist via two new `LogEntry` variants:
  - `LogEntry::TagNode { url: String, tag: String }` — add a tag to the node.
  - `LogEntry::UntagNode { url: String, tag: String }` — remove a tag from the node.
- The existing `LogEntry::PinNode { url, is_pinned }` is superseded. During startup log replay, old
  `PinNode` entries are converted: `PinNode { is_pinned: true }` → `TagNode { tag: "#pin" }`,
  `PinNode { is_pinned: false }` → `UntagNode { tag: "#pin" }`.
- `GraphBrowserApp` maintains `tag_index: HashMap<String, Vec<NodeKey>>` — keyed by tag string,
  value is the list of node keys carrying that tag. Updated on `TagNode`, `UntagNode`, `AddNode`,
  and `RemoveNode` intents.

#### Keyboard Shortcuts

| Key | Action |
| --- | --- |
| `B` | Toggle `#starred` on the selected node (backward-compatible with old bookmark shortcut) |
| `T` | Open the tag assignment panel on the selected node |

#### Tag Assignment UI

Small non-modal floating panel anchored near the selected node (full design in
`2026-02-20_node_badge_and_tagging_plan.md`):

- Text field with nucleo fuzzy autocomplete against existing tags + emoji names.
- `Enter` to add tag; click chip ✕ to remove; `Esc` to dismiss.
- Icon picker accessible from the field (emoji grid + Lucide subset).

#### Omnibar Integration

- `@b <query>` — cycles only `#starred` nodes matching the query (scope name backward-compatible).
- `is:starred` / `is:pinned` / `is:archived` / `is:unread` — faceted predicates in `Ctrl+F` search.
- `tag:<name>` — filter by any arbitrary user-defined tag.

Note: `#archive` nodes are hidden from the default graph view; `is:archived` in `Ctrl+F` is the
explicit way to surface them. `is:unread` surfaces nodes the user has not yet activated.

#### Delivery Surface

`graphshell://settings/bookmarks` — lists all tagged nodes grouped by tag, with add/remove/export
actions. Cross-reference: settings architecture plan §2.7.

#### Tasks

- [ ] Remove `is_bookmarked: bool` and `is_pinned: bool` from `Node`; add `tags: HashSet<String>`.
- [ ] Add `LogEntry::TagNode { url, tag }` and `LogEntry::UntagNode { url, tag }` variants; update
  `apply_log_entry()`.
- [ ] Add backward-compat replay for old `LogEntry::PinNode` entries: convert to `TagNode` /
  `UntagNode` with `#pin` during log replay in `apply_log_entry()`.
- [ ] Add `GraphIntent::TagNode { key: NodeKey, tag: String }` and
  `GraphIntent::UntagNode { key: NodeKey, tag: String }`; wire in `apply_intent()`.
- [ ] Implement `tag_index: HashMap<String, Vec<NodeKey>>` in `GraphBrowserApp`; update on
  `TagNode`, `UntagNode`, `AddNode`, `RemoveNode`.
- [ ] Update all physics anchor code that reads `node.is_pinned` to read
  `node.tags.contains("#pin")`.
- [ ] Keyboard shortcut `B` toggles `#starred` on selected node; wire into `KeyboardActions`,
  `input/mod.rs`, `KEYBINDINGS.md`, and help panel string.
- [ ] Keyboard shortcut `T` opens tag assignment panel; wire same locations.
- [ ] Add `@b` scope to omnibar scope dispatch: filter on `node.tags.contains("#starred")`.
- [ ] Define system tag name constants in `graph/node.rs` or a new `graph/tags.rs`:
  `pub const TAG_PIN: &str = "#pin"`, `TAG_STARRED`, `TAG_ARCHIVE`, `TAG_RESIDENT`,
  `TAG_PRIVATE`, `TAG_NOHISTORY`, `TAG_MONITOR`, `TAG_UNREAD`, `TAG_FOCUS`, `TAG_CLIP`. All system code
  uses these constants — a typo on a constant is a compile error.
- [ ] Auto-apply `#unread` on `AddNode`: in `apply_intent()` `AddNode` arm, insert
  `TAG_UNREAD` into the new node's `tags`.
- [ ] Auto-apply `#unread` on `UpdateNodeUrl`: in `apply_intent()` `UpdateNodeUrl` arm, if the
  node already had a URL (i.e. it changed rather than being set for the first time), re-apply
  `TAG_UNREAD`.
- [ ] Clear `#unread` on first activation: in the lifecycle reconciler, when a node transitions
  to `Active` for the first time in a session, emit `GraphIntent::UntagNode { tag: TAG_UNREAD }`.
- [ ] In graph view rendering: exclude nodes with `TAG_ARCHIVE` from the default node set.
  Add a "Show archived" toggle in the graph view toolbar (off by default). Archived nodes
  render at reduced opacity when the toggle is on.
- [ ] Wire `TagNode`/`UntagNode` intents through `is_user_undoable_intent()` (undoable actions).
- [ ] Add `is:starred`, `is:pinned`, `is:archived`, `is:unread`, `tag:<name>` predicates to
  `Ctrl+F` faceted search.
- [ ] Update `GraphNodeShape::ui()`: render per-tag badges (see badge plan for priority and layout).

#### Validation Tests

- `test_tag_node_intent_adds_tag` — `TagNode { tag: "#starred" }` → `node.tags.contains("#starred")`.
- `test_untag_node_intent_removes_tag` — `UntagNode { tag: "#starred" }` → tag no longer in set.
- `test_tag_log_entry_roundtrip` — serialize `TagNode` entry; deserialize → tag applied on replay.
- `test_tag_index_updates_on_add_remove` — add tagged node, remove node → `tag_index` no longer
  contains the node key under that tag.
- `test_at_b_scope_returns_only_starred` — graph with one `#starred` and one untagged node;
  `@b term` → only starred node in result set.
- `test_pin_tag_replaces_is_pinned` — node with `#pin` tag → physics simulation treats it as
  anchored (existing pin physics code reads `tags.contains("#pin")`).
- `test_old_pin_log_entry_replayed_as_tag` — `LogEntry::PinNode { is_pinned: true }` replayed →
  `node.tags.contains("#pin")`.
- `test_user_defined_tag_no_behavior` — add `tag: "work"` → no physics or bookmark effect; tag
  appears in `tag_index["work"]`.
- `test_add_node_auto_applies_unread` — `AddNode` intent → new node's `tags` contains `TAG_UNREAD`.
- `test_update_url_reapplies_unread` — node with existing URL; `UpdateNodeUrl` → `TAG_UNREAD`
  re-applied even if it was previously cleared.
- `test_unread_cleared_on_first_activation` — node with `#unread`; lifecycle transition to
  `Active` → `UntagNode { tag: TAG_UNREAD }` emitted; `node.tags` no longer contains `TAG_UNREAD`.
- `test_archive_excluded_from_default_graph_render` — node with `#archive` tag →
  `active_graph_nodes()` (or equivalent render filter) excludes it when "show archived" is off.
- `test_tag_node_intent_is_undoable` — `is_user_undoable_intent(GraphIntent::TagNode { .. })` →
  returns true.
- `test_untag_node_intent_is_undoable` — `is_user_undoable_intent(GraphIntent::UntagNode { .. })`
  → returns true.

---

### Phase 2: Node History

Per-node URL address history: when a node's URL changes via `SetNodeUrl`, the old URL is retained
as a history entry. This enables revisiting a previously-used URL from a node that has since
navigated elsewhere.

This is a near-term approximation of the Universal Node Content Model's version-controlled history
vision (`2026-02-18_universal_node_content_model.md`).

#### Data Model

- Add `url_history: Vec<String>` field to `Node` (most-recent-first; capped at 20 entries).
- **Approach**: derive from the fjall log on startup — scan `UpdateNodeUrl` entries per URL to
  reconstruct history. Append in-memory during the session. No new `LogEntry` variant needed
  initially.
  - Rationale: the fjall log already records `UpdateNodeUrl` with timestamps; reconstruction avoids
    schema changes. If persistent history beyond what the log retains is needed later, add
    `LogEntry::PushNodeUrlHistory`.
- History entries are NOT persisted in the snapshot path (`rkyv`) — they are reconstructed each
  session from the log.

#### UI

- "Node History" section in the Persistence Hub panel.
- Dropdown to select any node (active nodes first).
- For the selected node: chronological list of past URLs with timestamps.
- Per entry: "Open at this URL" button — emits `GraphIntent::CreateNodeAtUrl` with the historical
  URL (creates a new node; does not navigate the existing node backward).

#### Tasks

- [ ] Decide: confirm fjall-log-derived approach; implement `rebuild_url_history_from_log()` in
  `GraphBrowserApp` called after session startup load.
- [ ] Add `url_history: Vec<String>` to `Node`; update `apply_intent()` `SetNodeUrl` arm to push
  the previous URL to `url_history` (only when node already has a URL set).
- [ ] Cap at 20 entries: pop oldest when exceeded.
- [ ] Add "Node History" section to Persistence Hub panel.
- [ ] "Open at URL" button emits `GraphIntent::CreateNodeAtUrl { url: historical_url }`.

#### Validation Tests

- `test_set_node_url_pushes_to_history` — `SetNodeUrl` on a node with an existing URL → old URL
  appears first in `url_history`.
- `test_url_history_capped_at_20` — 21 `SetNodeUrl` calls → `url_history.len() == 20`.
- `test_url_history_not_pushed_on_initial_set` — first `SetNodeUrl` on a node with no URL →
  `url_history` remains empty.

---

### Phase 2.5: Session Restore Fidelity (Cold Resume Quality)

Improve cold-node restore so reopening a frozen/cold node feels closer to where the user left it,
without attempting full process-level webview checkpointing.

#### Scope

- Persist per-node session metadata needed for higher-fidelity restore:
  - navigation history entries + current index,
  - scroll position (x/y),
  - optional lightweight form draft snapshot (best-effort, opt-in).
- On reopen of a cold node, restore this metadata after webview creation.
- Keep warm-cache behavior separate: warm nodes still preserve full in-memory state while resident.

#### Non-Goals

- Full JS heap/DOM runtime snapshot and exact process resume.
- Persisting opaque engine internals beyond supported embedder/state APIs.

#### Tasks

- [ ] Add persisted `NodeSessionState` model (history/index/scroll + optional form draft payload).
- [ ] Capture/update session state from webview callbacks (history changes, scroll updates).
- [ ] Restore session state on cold-node reactivation (order: URL/history -> viewport -> scroll ->
  optional form draft replay).
- [ ] Add feature flag for form draft capture/replay (off by default until validated).
- [ ] Add Persistence Hub diagnostics row showing per-node restore fidelity status.

#### Validation Tests

- `test_cold_restore_reapplies_history_index` - node reopens at the correct history index.
- `test_cold_restore_reapplies_scroll_offset` - scroll position is restored after reopen.
- `test_form_draft_restore_feature_flag_guarded` - draft replay runs only when enabled.
- `test_restore_fallback_without_session_state` - cold reopen still succeeds when no
  session-state payload exists.

---

### Phase 3: Maintenance

Batch and retention operations for named persistence data.

#### 3.1 Batch Delete

- "Delete All Named Workspace Snapshots" and "Delete All Named Graph Snapshots" buttons in
  Persistence Hub.
- Both require an inline confirmation step (destructive button with double-click or "Confirm?"
  secondary prompt pattern consistent with existing palette confirmations).

#### 3.2 Retention Policy

- Extend the existing session autosave cadence/retention controls to named snapshot management:
  add an optional `max_named_snapshots: usize` cap (e.g., keep the 10 most recent); auto-purge
  oldest on save when the cap is exceeded.
- Cap is per-type (workspace snapshots and graph snapshots capped independently).

#### 3.3 Log Compaction

- The fjall log grows over time with all historical `AddNode`, `RemoveNode`, `UpdateNodeUrl`, etc.
  entries. A compact operation rewrites the log as the minimal set of entries that reproduces the
  current graph state.
- "Compact Log" button in Persistence Hub: destructive, requires explicit confirmation.
- Post-compaction: existing snapshots remain valid (they are stored in redb, not the fjall log).

#### 3.4 Export / Import

- "Export Graph as JSON" — serialize current `Graph` to JSON (via `serde_json`) for external use
  or backup.
- "Import Graph from JSON" — parse and replace current graph (not merge; merge complexity is
  deferred to FT7).
- Format: `Graph` struct serialized via `serde_json`; must round-trip through the rkyv-compatible
  struct layout.

#### Tasks

- [ ] Add batch-delete buttons with confirmation to Persistence Hub; wire to existing
  `delete_named_workspace_snapshot` / `delete_named_graph_snapshot` APIs.
- [ ] Implement `max_named_snapshots` cap in `app.rs`; enforce on save; expose control in
  Persistence Hub.
- [ ] Implement `compact_fjall_log()` in `app.rs`; wire "Compact Log" button in Persistence Hub
  with confirmation step.
- [ ] Implement `export_graph_json() -> Result<String>` and
  `import_graph_json(&str) -> Result<()>` methods on `GraphBrowserApp`.
- [ ] Wire export/import buttons in Persistence Hub (file picker for import; clipboard/file for
  export).

#### Validation Tests

- `test_compact_log_produces_minimal_replay` — after compact, loading from log yields the same
  graph state as before compaction.
- `test_export_import_roundtrip` — export graph to JSON; create new `GraphBrowserApp`; import →
  graphs are structurally equal (same nodes, edges, URLs).
- `test_batch_delete_clears_all_named_workspaces` — after batch delete, `list_named_workspace_snapshots()` returns empty.
- `test_max_named_snapshots_cap_enforced` — save 11 snapshots with cap=10 → oldest is removed,
  list has 10 entries.

---

### Phase 4: Encryption at Rest

The graph database contains qualitatively more sensitive data than ordinary browser history. A flat
history list reveals which sites were visited; the graph also reveals *how those sites relate to
each other* — research patterns, topic clusters, professional associations. The full persistence
layer (fjall log + redb snapshots) deserves stronger protection than browser history typically
receives.

#### Data Classification

| Data | Sensitivity | Treatment |
| --- | --- | --- |
| Graph topology + node URLs | High | Encrypt at rest |
| Node titles, tags, `url_history` | High | Encrypt at rest |
| Named workspace/graph snapshots | High | Encrypt at rest |
| `NodeSessionState` payloads (nav history, scroll, form drafts) | High | Encrypt at rest |
| Physics positions | Low — ephemeral layout | Included in snapshot; encrypted as a side effect |
| Thumbnails / favicons | Low — reconstructible from URL | Cache only; no encryption needed |

#### Key Management

Use OS-native secret storage to derive the encryption key — zero friction, no user prompt required
by default. Key is bound to the OS account.

- **Primary**: `keyring` crate (Windows DPAPI, macOS Keychain, Linux libsecret) — generate a
  random 32-byte key on first run and store it there.
- **Fallback/override**: Argon2-derived key from a user passphrase for portable vault use cases
  (opt-in, not default).
- **Principle**: the encryption key must never be stored adjacent to encrypted data. Key lives in
  the OS keychain; data lives in the fjall/redb app data directory.

#### Encryption Pipeline

```text
data → rkyv serialize → zstd compress → AES-256-GCM encrypt → fjall/redb write
```

Ordering rationale: compress before encrypt because encrypted bytes are high-entropy and
compress poorly. zstd and AES-256-GCM are independent byte transforms — fully compatible.
The `aes-gcm` crate (RustCrypto) provides authenticated encryption (AEAD), which gives both
confidentiality and tamper detection in a single pass.

#### Impact on Existing Phases

- **Phase 3.4 Export**: plaintext JSON export must carry a visible warning that the file is
  unencrypted. An optional encrypted export variant (e.g. CBOR + AES-256-GCM, or age-encrypted
  JSON) should be offered alongside the plaintext format.
- **Phase 3.3 Log Compaction**: the compaction operation reads and rewrites the log; it must read
  encrypted and write encrypted — no plaintext intermediary on disk.
- **Phase 2.5 Session Restore**: `NodeSessionState` payloads (navigation history, scroll, form
  drafts) are sensitive and must flow through the encrypted path.

#### Verse Forward-Compatibility

When Verse P2P sharing is implemented, content shared over the network should already be encrypted
at rest. The per-node encryption unit (compressed rkyv payload + AES-256-GCM tag) maps naturally
to a content-addressed store: `BLAKE3::hash(compressed_bytes)` → CID, then encrypt for transit.
The compress → hash → encrypt ordering ensures the CID covers the actual transfer unit.

#### Tasks

- [ ] On first run: generate a 32-byte random key; store in OS keychain via `keyring` crate.
- [ ] Add `PersistenceKey` abstraction in `persistence/mod.rs`; load key from OS keychain on
  startup; expose key-not-found error path.
- [ ] Wrap fjall log write path: `rkyv_bytes → zstd → aes_gcm::encrypt` for all sensitive entries.
- [ ] Wrap fjall log read path: `aes_gcm::decrypt → zstd → rkyv::from_bytes`.
- [ ] Wrap redb snapshot write path (same pipeline).
- [ ] Wrap redb snapshot read path.
- [ ] Migration path: on startup, detect unencrypted legacy database; prompt user for one-time
  in-place encryption migration before proceeding.
- [ ] Update Phase 3.4 export: add plaintext warning; add encrypted export option.
- [ ] Update Phase 3.3 compaction: verify compacted log is written through the encrypted path.

#### Validation Tests

- `test_roundtrip_encrypt_decrypt` — encrypt then decrypt a known byte payload → original bytes
  recovered exactly.
- `test_tampered_ciphertext_rejected` — flip one byte in ciphertext → AES-GCM returns
  authentication error.
- `test_key_not_stored_in_data_dir` — after init, no file in the fjall/redb directory contains
  the raw key bytes.
- `test_migration_detects_unencrypted_db` — a database written without encryption is detected as
  a legacy format on startup.
- `test_compaction_output_is_not_plaintext` — after log compaction, raw log bytes do not match
  the original unencrypted rkyv output format.

---

### Phase 5: Session Architecture

App-level session state (UI layout, panel states, physics config, input bindings, zoom/pan, DOI
weights) is currently scattered and mostly ephemeral. This phase introduces a dedicated
`session.log` WAL alongside the existing browsing log, giving session state the same durability
and replay-ability as graph state.

#### Motivation

The existing fjall WAL (`browsing.log`, renamed) records graph mutations (AddNode, AddEdge,
UpdateNodeUrl, TagNode, etc.). Session state — which workspace is active, how the window is laid
out, what the physics preset was — is not persisted across restarts. Losing this state makes the
app feel "reset" on each launch even when graph content survives.

Beyond durability, persisted session events are the prerequisite for the clipping algorithm: nodes
that have been Cold for multiple consecutive sessions and never revisited are dissolution
candidates. Without a session log to consult, DOI-based culling has no long-term signal.

#### Directory Structure

```text
~/.local/share/graphshell/
  sessions/
    <uuid>/              # one directory per session (app launch)
      session.log        # session state mutations (this phase)
      snapshots/         # rkyv snapshots coordinated with browsing log
  browsing.log           # renamed from current fjall WAL (graph mutations)
  browsing.redb          # current redb snapshot store (unchanged path)
```

#### Two-WAL Model

| WAL | Content | Append rate | Retention |
| --- | --- | --- | --- |
| `browsing.log` | Graph mutations: AddNode, AddEdge, TagNode, UpdateNodeUrl, etc. | Low (user actions) | Infinite default; compaction on demand (Phase 3.3) |
| `session.log` | Session mutations: WorkspaceChanged, LayoutChanged, PhysicsPresetChanged, NodeActivated, NodeCooled, ZoomChanged, etc. | Medium (continuous) | Infinite default; per-session retention configurable |

Both WALs append continuously. Since mutations are small binary records (tens of bytes each),
infinite retention is feasible for typical use (years of active use ≈ low hundreds of MB).

#### Session Log Entry Types

```rust
pub enum SessionLogEntry {
    /// App session started (new UUID, timestamp, graphshell version).
    SessionStart { session_id: Uuid, started_at: Timestamp, version: String },
    /// Active workspace changed.
    WorkspaceChanged { workspace_id: Uuid },
    /// Window layout tile tree changed.
    LayoutChanged { tiles_snapshot: TilesSnapshot },
    /// Physics preset or parameters changed.
    PhysicsStateChanged { preset: PhysicsPreset, params: PhysicsParams },
    /// Input binding changed.
    InputBindingChanged { command: String, binding: String },
    /// Zoom/pan camera state changed.
    CameraChanged { zoom: f32, pan_x: f32, pan_y: f32 },
    /// Node lifecycle: transitioned from Cold/Warm to Active.
    NodeActivated { url: String, activated_at: Timestamp },
    /// Node lifecycle: transitioned from Active/Warm to Cold.
    NodeCooled { url: String, cold_at: Timestamp, peak_pressure: MemoryPressure },
    /// Snapshot taken — links both WALs to a redb snapshot by shared UUID.
    SnapshotTaken { snapshot_id: Uuid, timestamp: Timestamp },
    /// App session ended (graceful shutdown).
    SessionEnd { session_id: Uuid, ended_at: Timestamp },
}
```

#### NodeActivityRecord (Clipping Foundation)

`NodeActivated` and `NodeCooled` events are the primary data source for the clipping algorithm.
A `NodeActivityRecord` aggregates across all sessions:

```rust
pub struct NodeActivityRecord {
    pub url: String,
    pub sessions_active: usize,     // sessions in which this node was activated at least once
    pub sessions_cold: usize,       // consecutive sessions ending with node cold
    pub last_activated: Timestamp,
    pub last_cooled: Timestamp,
    pub peak_pressure: MemoryPressure, // pressure level when last cooled
}
```

Nodes with `sessions_cold >= threshold` (configurable, default 5) and `last_activated` older than
`hot_retention_days` (from edge traversal plan §2.1) are dissolution candidates for the clipping
algorithm.

#### Coordinated Snapshot Timestamps

When a redb snapshot is written (periodic autosave or shutdown), a `SnapshotTaken` record is
appended to both WALs with the same `snapshot_id: Uuid` and `timestamp`. This links the two
timelines for recovery: given a redb snapshot, both WALs can be replayed from the matching
timestamp forward.

#### Save Buffer

Default: infinite (no cap). Users who prefer bounded storage can set `max_log_size_mb` in
preferences; when exceeded, automatic compaction (Phase 3.3) is triggered with a toast
notification.

#### Delivery Surface

Runtime diagnostics (session count, oldest session, total log size) appear in
`graphshell://settings/persistence`. Session log contents are browsable in
`graphshell://settings/history` (timeline view, from edge traversal plan §2.3).

#### Tasks

- [ ] Rename current fjall WAL directory/path to `browsing.log`; add migration for existing
  installs (old path still loads if new path absent).
- [ ] Add `SessionLogEntry` enum to persistence layer; implement append-only `session.log` WAL
  (fjall keyspace or plain file — TBD by performance measurement).
- [ ] On app startup: write `SessionStart` entry with a new session UUID.
- [ ] On graceful shutdown: write `SessionEnd` entry.
- [ ] On workspace change: write `WorkspaceChanged` entry.
- [ ] Wire `NodeActivated` / `NodeCooled` events from lifecycle reconciler to `session.log`.
- [ ] Implement `NodeActivityRecord` aggregation: scan `session.log` on startup; build
  `activity_records: HashMap<String, NodeActivityRecord>` keyed by URL.
- [ ] Append `SnapshotTaken` coordination record to both WALs on each autosave.
- [ ] Expose session diagnostics in `graphshell://settings/persistence` (session count, oldest
  session, log size estimates).

#### Validation Tests

- `test_session_start_entry_written_on_init` — new session → `SessionStart` entry present in log.
- `test_node_activated_written_on_lifecycle_transition` — node transitions Cold → Active →
  `NodeActivated` record written with correct URL and timestamp.
- `test_node_cooled_written_on_eviction` — node evicted from warm cache → `NodeCooled` written.
- `test_activity_record_aggregates_across_sessions` — two `NodeActivated` records for same URL →
  `sessions_active == 2`.
- `test_consecutive_cold_sessions_counted` — node cold in 3 consecutive sessions →
  `sessions_cold == 3`.
- `test_snapshot_coordination_timestamp_consistent` — `SnapshotTaken` in both WALs shares same
  `snapshot_id`.

---

## Findings

### Graph Topology Sensitivity

GraphShell's persistence is qualitatively more sensitive than a browser history file. A history
list reveals which URLs were visited; the graph also encodes *relationships* between those URLs —
which research threads connect, which domains cluster together, which pages a user linked manually.
This topology is richer and harder to reconstruct than raw history, which makes it both more
valuable to an attacker and more deserving of protection.

Phase 4 (Encryption at Rest) is the direct response. The `NodeSessionState` payloads from Phase
2.5 (form drafts, navigation index) add another high-sensitivity data class beyond the graph model
itself.

### Export Security and FT7 Import Hardening

Plaintext JSON export (Phase 3.4) is a deliberate escape hatch for interoperability and backup.
It must be labeled clearly as unencrypted in the UI and file metadata. An encrypted export variant
should be offered when Phase 4 is implemented.

For the FT7 browser import feature (Firefox/Chrome bookmark/history files): treat all imported
files as untrusted. Parse bookmark XML with a strict field allowlist; do not eval or navigate any
embedded URLs during import. Open SQLite history databases (`rusqlite`) in read-only mode and
iterate row-by-row — do not embed any file-derived data into SQL queries.

### Relationship to Older Plan

`2026-02-11_bookmarks_history_import_plan.md` described importing from Firefox/Chrome bookmark
export files and history SQLite databases. That feature (FT7 in IMPLEMENTATION_ROADMAP) is
orthogonal to this plan and remains in the future-features queue. The import wizard is not in
scope here.

### Tags vs. Edge Semantics

Tags (`tags: HashSet<String>`) are user-applied node attributes, not graph relationships. Using a
`UserGrouped` edge for bookmarking was considered and rejected: it would pollute the graph
topology, appear in the physics layout, and conflate "user-created connection" with "user
preference tag."

The earlier `is_bookmarked: bool` and `is_pinned: bool` scalar fields have been unified into the
tag system (Phase 1, 2026-02-20). `#pin` carries the physics anchor effect; `#starred` is the
soft bookmark. User-defined tags are purely organizational. Tab lifecycle pinning (preventing
webview eviction) is a separate workspace-tile property (`tile.is_resident: bool`) and is not a
node tag — the same node can be resident in one workspace and evictable in another.

### Node History and Universal Node Content Model

The Universal Node Content Model vision (`2026-02-18_universal_node_content_model.md`) describes
full version-controlled content history per node. Phase 2 here is an intentional subset — URL
address history only — with a clear upgrade path once the universal model's content store exists.

### Log Compaction Safety

Compacting the fjall log is safe for existing redb snapshots because snapshots store complete
graph state (not log replay references). The only risk is if startup logic relies on log
reconstruction for fields not stored in snapshots. Audit `load_snapshot()` and
`apply_log_entry()` interaction before implementing §3.3.

---

## Progress

### 2026-02-19 — Session 1

- Plan created from edge plan §Remaining #3 and review of existing Persistence Hub implementation.
- Phase 1 (Bookmarks): full task list and unit test stubs.
- Phase 2 (Node History): task list; fjall-log-derived approach recommended.
- Phase 3 (Maintenance): task list for batch delete, retention cap, log compaction, export/import.
- Implementation not started.

### 2026-02-20 - Session 2

- Added baseline lifecycle/sessioning policy tied into runtime reconciliation:
  - active MRU cap (4),
  - warm MRU cap (12),
  - pressure-aware demotion/eviction behavior.
- Added Persistence Hub runtime diagnostics for lifecycle counts and memory pressure.
- Added or updated unit tests for active/warm MRU eviction behavior.
- Phase 1/2/3 feature scopes (Bookmarks, Node History UI, Maintenance batch tools) still pending.

### 2026-02-20 - Session 3

- Added settings architecture cross-reference table (Phase → delivery surface mapping).
- Rewrote Phase 1: replaced `is_bookmarked: bool` + `SetBookmark` log entry with unified tag
  model (`tags: HashSet<String>`, `TagNode`/`UntagNode` log entries, `tag_index`). `is_pinned`
  also folded into `#pin` tag with backward-compat replay of old `PinNode` log entries.
  Documented distinction between node `#pin` tag (physics anchor) and tab lifecycle pinning
  (`tile.is_resident: bool`, not a node tag).
- Updated Phase 4 data classification table: "bookmarks" → "tags".
- Updated Findings: "Bookmark vs. Edge Semantics" → "Tags vs. Edge Semantics" with explanation
  of the unification rationale.
- Added Phase 5 (Session Architecture): two-WAL model (`session.log` + `browsing.log`),
  `SessionLogEntry` types, `NodeActivityRecord` as clipping foundation, coordinated snapshot
  timestamps, infinite save buffer default.
- Implementation not started for any phase.
